<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Face reveal</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Bungee&family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            color: white;
            font-family: 'Bungee', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            text-align: center;
        }
        canvas { display: block; }
        #ui-container, #video-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: none;
        }
        .menu-card {
            background: linear-gradient(145deg, rgba(0,0,0,0.7), rgba(0,0,0,0.85));
            padding: 2rem 3rem;
            border-radius: 20px;
            pointer-events: all;
            border: 4px solid #A98B61;
            max-width: 90%;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5), inset 0 0 15px rgba(255,255,255,0.1);
        }
        h1 {
            font-family: 'Press Start 2P', cursive;
            font-size: clamp(1.5rem, 5vw, 2.5rem);
            color: #A98B61;
            text-shadow: 4px 4px 0px #000;
            margin-bottom: 1rem;
        }
        p { font-size: 1rem; margin-top: 0; line-height: 1.5; }
        .button-group {
            display: flex;
            gap: 1rem;
            margin-top: 1.5rem;
        }
        button {
            font-family: inherit;
            font-size: 1.2rem;
            padding: 15px 30px;
            border-radius: 10px;
            border: 2px solid white;
            background-color: #8B4513;
            color: white;
            cursor: pointer;
            box-shadow: 0 5px 0 #5a2d0c;
            transition: all 0.07s ease-in-out;
            margin-top: 1rem;
        }
        button:active { transform: translateY(5px); box-shadow: 0 0px 0 #5a2d0c; }
        button.secondary { background-color: #555; box-shadow: 0 5px 0 #333; }
        
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            font-size: 1.8rem;
        }
        .hud-left, .hud-right {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 15px;
        }
        .hud-right { align-items: flex-end; }

        .hud-item {
            background: rgba(0,0,0,0.5);
            padding: 10px 20px;
            border-radius: 10px;
            text-shadow: 2px 2px 4px #000;
            display: flex;
            align-items: center;
        }
        #fuel-container { width: 220px; flex-direction: column; align-items: flex-start; }
        #fuel-bar-background {
            width: 100%; height: 20px; background-color: #555;
            border: 2px solid #fff; border-radius: 5px; margin-top: 5px;
        }
        #fuel-bar {
            width: 100%; height: 100%; background: linear-gradient(90deg, #ff4d4d, #ffff4d, #4dff4d);
            border-radius: 3px; transition: width 0.2s linear;
        }
        #shield-icon, #magnet-icon, #boost-icon {
            font-size: 2.8rem;
            filter: drop-shadow(2px 4px 6px black);
            background: none;
            padding: 0;
            display: none;
        }
        #video-container {
            background-color: rgba(0,0,0,0.9);
            pointer-events: all;
            z-index: 100;
        }
        #reward-video {
            width: 80%;
            max-width: 960px;
            border: 4px solid #A98B61;
            border-radius: 10px;
        }
        #music-toggle-button {
            font-size: 2.2rem;
            background: rgba(0,0,0,0.5);
            padding: 5px 15px;
            border-radius: 10px;
            cursor: pointer;
            pointer-events: all;
        }
    </style>
</head>
<body>
    <div id="ui-container">
        <div id="menu" class="menu-card">
            <h1>RUNN DK RUNN</h1>
            <p>Swipe to Move | Keyboard Arrows Work Too!</p>
            <p>Score 1000 points for a reward!</p>
            <button id="start-button">Start Game</button>
        </div>
        <div id="revive-screen" class="menu-card" style="display: none;">
            <h1>Second Chance?</h1>
            <p id="revive-cost">Revive for 1000 points?</p>
            <div class="button-group">
                <button id="revive-button">Revive</button>
                <button id="end-run-button" class="secondary">End Run</button>
            </div>
        </div>
        <div id="game-over" class="menu-card" style="display: none;">
            <h1>Game Over</h1>
            <p id="final-score"></p>
            <button id="restart-button">Try Again</button>
        </div>
    </div>
    <div id="video-container" style="display: none;">
        <video id="reward-video" controlslist="nodownload"></video>
    </div>
    <div id="hud" style="display: none;">
        <div class="hud-left">
            <div id="score-container" class="hud-item">Score: <span id="score">0</span></div>
             <div id="shield-icon">üõ°Ô∏è</div>
             <div id="magnet-icon">üß≤</div>
             <div id="boost-icon">‚ö°</div>
        </div>
        <div class="hud-right">
            <div id="fuel-container" class="hud-item">
                <div>Fuel</div>
                <div id="fuel-bar-background"><div id="fuel-bar"></div></div>
            </div>
            <div id="music-toggle-button">üîä</div>
        </div>
    </div>
    <script>
    // --- SETUP & CONFIG ---
    let scene, camera, renderer, clock, composer, textureLoader;
    let gameState = 'menu';
    const LANE_WIDTH = 4, GRAVITY = -30, BASE_FOV = 60, REVIVE_COST = 1000;

    // --- GAME OBJECTS ---
    let player, chaser, path, audioManager, particleSystem, speedLines, godRays;
    
    // --- PLAYER STATE ---
    const playerState = {
        lane: 1, targetLane: 1, yVelocity: 0,
        baseSpeed: 3, speed: 3, progress: 0,
        fuel: 100, score: 0,
        isJumping: false, isSliding: false, slideTimer: 0, hasShield: false,
        isMagnetActive: false, magnetTimer: 0,
        isStumbling: false, stumbleTimer: 0,
        isBoosting: false, boostTimer: 0,
        jumpAnticipation: 0, landImpact: 0,
        hasRevived: false,
        nextScoreMilestone: 1000,
    };
    
    // --- UI ELEMENTS ---
    const ui = {
        menu: document.getElementById('menu'), gameOver: document.getElementById('game-over'),
        reviveScreen: document.getElementById('revive-screen'),
        videoContainer: document.getElementById('video-container'),
        rewardVideo: document.getElementById('reward-video'),
        hud: document.getElementById('hud'), score: document.getElementById('score'),
        finalScore: document.getElementById('final-score'), fuelBar: document.getElementById('fuel-bar'),
        shieldIcon: document.getElementById('shield-icon'), magnetIcon: document.getElementById('magnet-icon'),
        boostIcon: document.getElementById('boost-icon'), startButton: document.getElementById('start-button'),
        restartButton: document.getElementById('restart-button'),
        reviveButton: document.getElementById('revive-button'),
        endRunButton: document.getElementById('end-run-button'),
        musicToggleButton: document.getElementById('music-toggle-button'),
    };

    // --- AUDIO MANAGER ---
    class AudioManager { // ... (No changes)
        constructor() {
            this.isMuted = false;
            this.sounds = {
                jump: new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.2 } }).toDestination(),
                slide: new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.01, decay: 0.15, sustain: 0, release: 0.1 } }).toDestination(),
                collect: new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.2 } }).toDestination(),
                crash: new Tone.NoiseSynth({ noise: { type: 'brown' }, envelope: { attack: 0.05, decay: 0.5, sustain: 0.2, release: 0.5 } }).toDestination(),
                stumble: new Tone.Synth({ oscillator: { type: 'sawtooth' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.1 } }).toDestination(),
                boost: new Tone.Synth({ oscillator: { type: 'pulse', width: 0.2 }, envelope: { attack: 0.01, decay: 0.5, sustain: 0.1, release: 0.5 } }).toDestination(),
                revive: new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 0.5, sustain: 0.1, release: 0.5 } }).toDestination(),
            };
            this.sounds.collect.volume.value = -6;
            const reverb = new Tone.Reverb(2).toDestination();
            const delay = new Tone.FeedbackDelay("8n", 0.5).toDestination();
            const musicSynth = new Tone.FMSynth({ harmonicity: 3, modulationIndex: 10, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 1 } }).connect(reverb).connect(delay);
            musicSynth.volume.value = -20;
            const pattern = new Tone.Pattern((time, note) => { musicSynth.triggerAttackRelease(note, '16n', time); }, ['A2', 'C3', 'E3', 'G3', 'A3', 'C4'], "upDown").start(0);
            Tone.Transport.bpm.value = 120;
        }
        play(sound) {
            if (!this.sounds[sound] || Tone.context.state !== 'running') return;
            if (sound === 'jump') this.sounds.jump.triggerAttackRelease('C5', '8n');
            if (sound === 'slide') this.sounds.slide.triggerAttackRelease('4n');
            if (sound === 'collect') this.sounds.collect.triggerAttackRelease('E6', '16n');
            if (sound === 'crash') this.sounds.crash.triggerAttackRelease('1n');
            if (sound === 'stumble') this.sounds.stumble.triggerAttackRelease('F3', '8n');
            if (sound === 'boost') this.sounds.boost.triggerAttackRelease('C4', '4n');
            if (sound === 'revive') this.sounds.revive.triggerAttackRelease('G5', '2n');
        }
        startMusic() { if (Tone.context.state === 'running') Tone.Transport.start(); }
        stopMusic() { Tone.Transport.stop(); }
        toggleMusic() { this.isMuted = !this.isMuted; Tone.Master.mute = this.isMuted; }
    }
    
    // --- PARTICLE SYSTEMS ---
    class ParticleSystem { constructor(count, color) { const geo = new THREE.BufferGeometry(); const vertices = []; this.velocities = []; this.lifespans = []; for (let i = 0; i < count; i++) { vertices.push(0, 0, 0); this.velocities.push({ x: 0, y: 0, z: 0 }); this.lifespans.push(0); } geo.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3)); const mat = new THREE.PointsMaterial({ color: color, size: 0.2, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false }); this.points = new THREE.Points(geo, mat); scene.add(this.points); } explode(position) { let e=0; for (let i=0; i<this.lifespans.length&&e<20; i++){ if(this.lifespans[i]<=0){ this.points.geometry.attributes.position.setXYZ(i, position.x, position.y, position.z); this.velocities[i]={x:(Math.random()-.5)*3, y:Math.random()*3+1, z:(Math.random()-.5)*3}; this.lifespans[i]=Math.random()*.5+.2; e++; } } this.points.geometry.attributes.position.needsUpdate = true; } update(delta) { let n=false; for (let i=0; i<this.lifespans.length; i++){ if(this.lifespans[i]>0){ n=true; this.lifespans[i]-=delta; const p=this.points.geometry.attributes.position; p.setXYZ(i, p.getX(i)+this.velocities[i].x*delta, p.getY(i)+this.velocities[i].y*delta, p.getZ(i)+this.velocities[i].z*delta); this.velocities[i].y-=9.8*delta; if(this.lifespans[i]<=0)p.setXYZ(i,0,-100,0); } } if(n)this.points.geometry.attributes.position.needsUpdate = true; } }
    class SpeedLines extends ParticleSystem { constructor(count) { super(count, 0xffffff); this.points.material.size = 0.1; } show() { for(let i=0; i<this.lifespans.length; i++){ if(this.lifespans[i]<=0){ const p=this.points.geometry.attributes.position; const R=10, r=R*Math.sqrt(Math.random()), t=Math.random()*2*Math.PI; p.setXYZ(i, r*Math.cos(t), r*Math.sin(t), -20); this.velocities[i]={x:0, y:0, z:150}; this.lifespans[i]=.2; } } } update(delta) { let n=false; for(let i=0; i<this.lifespans.length; i++){ if(this.lifespans[i]>0){ n=true; this.lifespans[i]-=delta; const p=this.points.geometry.attributes.position; p.setZ(i, p.getZ(i)+this.velocities[i].z*delta); if(this.lifespans[i]<=0)this.lifespans[i]=0; } } if(n)this.points.geometry.attributes.position.needsUpdate = true; } }

    // --- PATH AND WORLD GENERATION ---
    class Path { constructor() { this.segments=[]; this.objects=[]; this.collectibles=[]; this.segmentLength=15; this.curvePoints=[new THREE.Vector3(0,0,0)]; this.currentDirection=new THREE.Vector3(0,0,-1); this.pathTexture=this.createPathTexture(); this.generateInitialPath(); } createPathTexture() { const c=document.createElement('canvas');c.width=128;c.height=128;const x=c.getContext('2d');x.fillStyle='#6B5B49';x.fillRect(0,0,128,128);x.strokeStyle='#5A4B3A';x.lineWidth=2;x.beginPath();x.moveTo(0,64);x.lineTo(128,64);x.moveTo(64,0);x.lineTo(64,128);x.stroke();for(let i=0;i<500;i++){const a=Math.random()*128,b=Math.random()*128,s=Math.random()*2,h=Math.floor(Math.random()*30)+60;x.fillStyle=`rgb(${h},${h},${h},0.5)`;x.fillRect(a,b,s,s);}const t=new THREE.CanvasTexture(c);t.wrapS=THREE.RepeatWrapping;t.wrapT=THREE.RepeatWrapping;t.repeat.set(4,20);return t;} generateInitialPath() { for (let i = 0; i < 30; i++) this.extend(); } extend() { const l=this.curvePoints[this.curvePoints.length-1],n=l.clone().add(this.currentDirection.clone().multiplyScalar(this.segmentLength));n.y+= (Math.random()-.5)*1.5;if(n.y<-3)n.y=-3;if(n.y>3)n.y=3;this.curvePoints.push(n);this.buildSegmentMesh(this.curvePoints.length-2); } buildSegmentMesh(index) { const p1=this.curvePoints[index],p2=this.curvePoints[index+1],d=p2.clone().sub(p1).normalize(),g=new THREE.BoxGeometry(LANE_WIDTH*3+2,.5,this.segmentLength),m=new THREE.MeshLambertMaterial({map:this.pathTexture}),h=new THREE.Mesh(g,m);h.receiveShadow=true;h.position.copy(p1.clone().add(p2).multiplyScalar(.5));h.quaternion.setFromUnitVectors(new THREE.Vector3(0,0,-1),d);h.userData.pathIndex=index;scene.add(h);this.segments.push({mesh:h,p1,p2});this.spawnEnvironment(h.position,d,index);if(index>1&&Math.random()<.8)this.spawnObject(index); } spawnEnvironment(pos, dir, index) { const s=Math.random()>.5?1:-1,d=20+Math.random()*25,r=new THREE.Vector3().crossVectors(dir,new THREE.Vector3(0,1,0)),eP=pos.clone().add(r.multiplyScalar(d*s));eP.y=-1;let o;const sc=Math.random()*1.5+1.2,tR=Math.random();if(tR>.6){const tG=new THREE.CylinderGeometry(.5,.6,8+Math.random()*8,8),tM=new THREE.MeshLambertMaterial({color:0x5D4037});o=new THREE.Mesh(tG,tM);const lG=new THREE.IcosahedronGeometry(3+Math.random()*2,0),lM=new THREE.MeshLambertMaterial({color:0x4CAF50}),l=new THREE.Mesh(lG,lM);l.position.y=o.geometry.parameters.height;o.add(l);}else if(tR>.3){const rG=new THREE.IcosahedronGeometry(1.5+Math.random()*3,0),rM=new THREE.MeshLambertMaterial({color:0x757575});o=new THREE.Mesh(rG,rM);}else{const pG=new THREE.CylinderGeometry(.8,.8,10+Math.random()*10,8),pM=new THREE.MeshLambertMaterial({color:0x999999});o=new THREE.Mesh(pG,pM);o.rotation.z=(Math.random()-.5)*.5;} o.scale.set(sc,sc,sc);o.position.copy(eP);o.userData.pathIndex=index;scene.add(o);this.objects.push(o); } spawnObject(pathIndex) { const p1=this.curvePoints[pathIndex],p2=this.curvePoints[pathIndex+1],pos=p1.clone().lerp(p2,Math.random()*.8+.1),lane=Math.floor(Math.random()*3),typeRoll=Math.random(); let obj,isC=false; if(typeRoll<.4){const oT=Math.random()>.5?'jump':'slide';obj=oT==='jump'?this.createLogObstacle():this.createArchObstacle();obj.userData={type:'obstacle',obsType:oT};} else if(typeRoll<.5){obj=this.createStumbleObstacle();obj.userData={type:'stumble'};} else{isC=true;if(typeRoll<.7){obj=this.createFuelCollectible();obj.userData={type:'fuel'};} else if(typeRoll<.8){obj=this.createShieldCollectible();obj.userData={type:'shield'};} else if(typeRoll<.83){obj=this.createBoostCollectible();obj.userData={type:'boost'};} else if(typeRoll<.88){obj=this.createMagnetCollectible();obj.userData={type:'magnet'};} else{obj=this.createCoinCollectible();obj.userData={type:'coin'};}} obj.castShadow=true;obj.userData.lane=lane;const pS=pos.clone().sub(p1).length()/this.segmentLength;obj.userData.progress=pathIndex+pS;obj.userData.pathIndex=pathIndex;const oP=this.getPositionAt(obj.userData.progress,lane);obj.position.copy(oP);if(obj.userData.type!=='obstacle'&&obj.userData.type!=='stumble')obj.position.y+=1;const oR=this.getRotationAt(obj.userData.progress);obj.quaternion.copy(oR);if(isC)this.collectibles.push(obj);this.objects.push(obj);scene.add(obj);} createLogObstacle(){const g=new THREE.Group(),o=new THREE.CylinderGeometry(.7,.7,LANE_WIDTH,8),m=new THREE.MeshLambertMaterial({color:0x66402D}),l=new THREE.Mesh(o,m);l.rotation.z=Math.PI/2;l.position.y=.7;g.add(l);return g} createArchObstacle(){const g=new THREE.Group(),m=new THREE.MeshLambertMaterial({color:0x888888}),bG=new THREE.BoxGeometry(.8,4,.8),lP=new THREE.Mesh(bG,m);lP.position.set(-LANE_WIDTH/2,2,0);const rP=new THREE.Mesh(bG,m);rP.position.set(LANE_WIDTH/2,2,0);const tG=new THREE.BoxGeometry(LANE_WIDTH+.8,.8,.8),tB=new THREE.Mesh(tG,m);tB.position.y=4;g.add(lP,rP,tB);return g} createCoinCollectible(){const g=new THREE.TorusGeometry(.5,.15,8,16),m=new THREE.MeshStandardMaterial({color:0xFFD700,emissive:0xcc9900});return new THREE.Mesh(g,m)} createFuelCollectible(){const g=new THREE.Group(),mM=new THREE.MeshLambertMaterial({color:0x20c20e}),cM=new THREE.MeshLambertMaterial({color:0x666666}),b=new THREE.Mesh(new THREE.CylinderGeometry(.5,.5,1,12),mM),t=new THREE.Mesh(new THREE.CylinderGeometry(.55,.55,.1,12),cM);t.position.y=.5;const o=t.clone();o.position.y=-.5;g.add(b,t,o);return g} createShieldCollectible(){const s=new THREE.Shape();s.moveTo(0,2);s.lineTo(1,1);s.lineTo(1,-1);s.lineTo(0,-2);s.lineTo(-1,-1);s.lineTo(-1,1);s.lineTo(0,2);const g=new THREE.ShapeGeometry(s),m=new THREE.MeshBasicMaterial({color:0x03A9F4,emissive:0x03A9F4,side:THREE.DoubleSide});const h=new THREE.Mesh(g,m);h.scale.set(.6,.6,.6);return h} createStumbleObstacle(){const g=new THREE.IcosahedronGeometry(.3,0),m=new THREE.MeshLambertMaterial({color:0x967969}),r=new THREE.Mesh(g,m);r.position.y=.15;return r} createMagnetCollectible(){const g=new THREE.Group(),mR=new THREE.MeshStandardMaterial({color:0xff0000,emissive:0xcc0000}),mW=new THREE.MeshStandardMaterial({color:0xeeeeee,emissive:0x999999}),bG=new THREE.CylinderGeometry(.3,.3,.8,12),t=new THREE.Mesh(bG,mR);t.position.x=-.4;const b=new THREE.Mesh(bG,mW);b.position.x=.4;g.add(t,b);const brG=new THREE.BoxGeometry(.8,.3,.3),br=new THREE.Mesh(brG,mR);br.position.y=.4;g.add(br);g.rotation.z=Math.PI/4;return g} createBoostCollectible(){const s=new THREE.Shape();s.moveTo(0,2);s.lineTo(.5,.5);s.lineTo(0,.5);s.lineTo(0,-2);s.lineTo(-.5,-.5);s.lineTo(0,-.5);s.lineTo(0,2);const g=new THREE.ShapeGeometry(s),m=new THREE.MeshBasicMaterial({color:0xFFFF00,emissive:0xFFFF00,side:THREE.DoubleSide});const b=new THREE.Mesh(g,m);b.scale.set(.7,.7,.7);return b} getPositionAt(p,l){let i=Math.floor(p);if(i<0)i=0;else if(i>=this.curvePoints.length-1)i=this.curvePoints.length-2;if(this.curvePoints.length<2)return new THREE.Vector3();const p1=this.curvePoints[i],p2=this.curvePoints[i+1],o=p1.clone().lerp(p2,p-i),d=p2.clone().sub(p1).normalize(),r=new THREE.Vector3().crossVectors(d,new THREE.Vector3(0,1,0));o.add(r.multiplyScalar((l-1)*LANE_WIDTH));return o} getRotationAt(p){let i=Math.floor(p);if(i<0)i=0;else if(i>=this.curvePoints.length-1)i=this.curvePoints.length-2;if(this.curvePoints.length<2)return new THREE.Quaternion();const p1=this.curvePoints[i],p2=this.curvePoints[i+1],d=p2.clone().sub(p1).normalize();return new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,-1),d)} update(){while(this.curvePoints.length<playerState.progress+30)this.extend();this.segments=this.cleanup(this.segments,s=>s.mesh,10);this.objects=this.cleanup(this.objects,o=>o,15);this.collectibles=this.cleanup(this.collectibles,o=>o,15);} cleanup(a,g,t){return a.filter(i=>{const m=g(i);if(!m)return false;const p=Math.floor(playerState.progress);if(p>m.userData.pathIndex+t){scene.remove(m);if(m.geometry)m.geometry.dispose();if(m.material)m.material.dispose();return false;}return true;});} }
    
    function init() {
        scene = new THREE.Scene(); scene.fog = new THREE.Fog(0x87CEEB, 50, 250);
        clock = new THREE.Clock();
        renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap; renderer.setClearColor(0x87CEEB); document.body.appendChild(renderer.domElement);
        camera = new THREE.PerspectiveCamera(BASE_FOV, window.innerWidth / window.innerHeight, 0.1, 1000);
        scene.add(new THREE.HemisphereLight(0xffffbb, 0x080820, 0.8));
        scene.add(new THREE.AmbientLight(0x404040, 0.5));
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(10, 20, 5); dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048; dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.left = -30; dirLight.shadow.camera.right = 30; dirLight.shadow.camera.top = 30; dirLight.shadow.camera.bottom = -30;
        scene.add(dirLight);
        const groundGeo = new THREE.PlaneGeometry(1000, 1000); const groundMat = new THREE.MeshLambertMaterial({ color: 0x4CAF50 });
        const ground = new THREE.Mesh(groundGeo, groundMat); ground.rotation.x = -Math.PI / 2; ground.position.y = -5; scene.add(ground);
        const skyGeo = new THREE.SphereGeometry(500, 32, 15); const skyMat = new THREE.MeshBasicMaterial({ map: createSkyTexture(), side: THREE.BackSide });
        scene.add(new THREE.Mesh(skyGeo, skyMat));
        
        textureLoader = new THREE.TextureLoader();

        const renderScene = new THREE.RenderPass(scene, camera);
        const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.85; bloomPass.strength = 0.6; bloomPass.radius = 0.4;
        composer = new THREE.EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        audioManager = new AudioManager();
        particleSystem = new ParticleSystem(100, 0xFFD700);
        speedLines = new SpeedLines(100);
        godRays = new ParticleSystem(50, 0xFFFF88);
        godRays.points.material.size = 0.5;

        createPlayer(); createChaser(); path = new Path();
        window.addEventListener('resize', onWindowResize, false);
        document.addEventListener('keydown', handleKeyDown, false);
        // NEW: Touch controls
        let touchStartX = 0; let touchStartY = 0;
        renderer.domElement.addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        });
        renderer.domElement.addEventListener('touchend', (e) => {
            if (gameState !== 'playing') return;
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            const swipeThreshold = 30;

            if (Math.abs(deltaX) > Math.abs(deltaY)) { // Horizontal swipe
                if (deltaX > swipeThreshold) { // Right
                    if (playerState.targetLane < 2) playerState.targetLane++;
                } else if (deltaX < -swipeThreshold) { // Left
                    if (playerState.targetLane > 0) playerState.targetLane--;
                }
            } else { // Vertical swipe
                if (deltaY > swipeThreshold) { // Down
                    if (!playerState.isJumping && !playerState.isSliding) {
                        playerState.isSliding=true;playerState.slideTimer=.6;audioManager.play('slide');
                    }
                } else if (deltaY < -swipeThreshold) { // Up
                    if (!playerState.isJumping && !playerState.isSliding) {
                        playerState.isJumping=true;playerState.yVelocity=12;audioManager.play('jump');playerState.jumpAnticipation=0.2;
                    }
                }
            }
        });


        ui.startButton.addEventListener('click', () => Tone.start().then(startGame));
        ui.restartButton.addEventListener('click', startGame);
        ui.reviveButton.addEventListener('click', revivePlayer);
        ui.endRunButton.addEventListener('click', () => showGameOver());
        ui.musicToggleButton.addEventListener('click', toggleMusic);
    }
    
    function createSkyTexture() { const c=document.createElement("canvas");c.width=512;c.height=512;const x=c.getContext("2d");const g=x.createLinearGradient(0,0,0,512);g.addColorStop(0,"#87CEEB");g.addColorStop(0.7,"#FFFFFF");x.fillStyle=g;x.fillRect(0,0,512,512);return new THREE.CanvasTexture(c);}
    function startGame() { Object.assign(playerState,{lane:1,targetLane:1,yVelocity:0,speed:playerState.baseSpeed,progress:0,fuel:100,score:0,isJumping:false,isSliding:false,hasShield:false,isMagnetActive:false,isStumbling:false,isBoosting:false,hasRevived:false,nextScoreMilestone:1000}); path.segments.forEach(s=>scene.remove(s.mesh)); path.objects.forEach(o=>{scene.remove(o);if(o.geometry)o.geometry.dispose();if(o.material)o.material.dispose();}); path.segments=[];path.objects=[];path.collectibles=[];path.curvePoints=[new THREE.Vector3(0,0,0)];path.currentDirection=new THREE.Vector3(0,0,-1);path.generateInitialPath(); player.position.set(0,1.5,0);player.rotation.set(0,0,0);player.scale.set(1.5,1.5,1.5);chaser.position.set(0,0,20); ui.menu.style.display='none';ui.gameOver.style.display='none';ui.reviveScreen.style.display='none';ui.hud.style.display='flex'; ui.score.innerText=0;ui.shieldIcon.style.display='none';ui.magnetIcon.style.display='none';ui.boostIcon.style.display='none'; gameState='playing'; audioManager.startMusic(); animate(); }
    function createPlayer() { 
        player=new THREE.Group();const bM=new THREE.MeshStandardMaterial({color:0x005A9C,roughness:0.8}),sM=new THREE.MeshStandardMaterial({color:0xEDB98A,roughness:0.8}),pM=new THREE.MeshStandardMaterial({color:0x333333,roughness:0.8});const faceTexture=textureLoader.load('https://res.cloudinary.com/dfmhr0tu8/image/upload/v1756477756/nagu-removebg-preview_iq7uil.png',()=>{},undefined,()=>{head.material=sM;});const headMat=new THREE.MeshStandardMaterial({map:faceTexture,roughness:0.8});player.scale.set(1.5,1.5,1.5);const hG=new THREE.SphereGeometry(.4,32,32),h=new THREE.Mesh(hG,headMat);h.position.y=1.3;h.castShadow=true;player.add(h);const tG=new THREE.CylinderGeometry(.5,.3,1.2,8),t=new THREE.Mesh(tG,bM);t.position.y=.5;t.castShadow=true;player.add(t);const aG=new THREE.CylinderGeometry(.15,.1,.9,8),lA=new THREE.Mesh(aG,sM);lA.position.set(-.6,.8,0);lA.name="leftArm";lA.castShadow=true;player.add(lA);const rA=lA.clone();rA.position.x=.6;rA.name="rightArm";player.add(rA);const lG=new THREE.CylinderGeometry(.2,.15,1,8),lL=new THREE.Mesh(lG,pM);lL.position.set(-.25,-.4,0);lL.name="leftLeg";lL.castShadow=true;player.add(lL);const rL=lL.clone();rL.position.x=.25;rL.name="rightLeg";player.add(rL);const sG=new THREE.SphereGeometry(1.5,16,16),sMat=new THREE.MeshBasicMaterial({color:0x03A9F4,transparent:true,opacity:.3}),sMesh=new THREE.Mesh(sG,sMat);sMesh.name='shield';sMesh.visible=false;sMesh.position.y=.5;player.add(sMesh);scene.add(player);
    }
    function createChaser() { const cG=new THREE.IcosahedronGeometry(3,1),cM=new THREE.MeshLambertMaterial({color:0x1a1a1a});chaser=new THREE.Mesh(cG,cM);scene.add(chaser); }
    function handleKeyDown(e) { if(gameState!=='playing')return; const k=e.key,kL=k.toLowerCase(); if((k==='ArrowLeft'||kL==='a')&&playerState.targetLane>0)playerState.targetLane--; else if((k==='ArrowRight'||kL==='d')&&playerState.targetLane<2)playerState.targetLane++; else if((k===' '||k==='ArrowUp'||kL==='w')&&!playerState.isJumping&&!playerState.isSliding){ playerState.isJumping=true;playerState.yVelocity=12;audioManager.play('jump');playerState.jumpAnticipation=0.2;} else if((k==='ArrowDown'||kL==='s')&&!playerState.isJumping&&!playerState.isSliding){playerState.isSliding=true;playerState.slideTimer=.6;audioManager.play('slide');} }
    function updatePlayer(delta) {
        if(playerState.isStumbling){playerState.stumbleTimer-=delta;if(playerState.stumbleTimer<=0)playerState.isStumbling=false;}
        playerState.progress+=playerState.speed*delta;
        playerState.lane=THREE.MathUtils.lerp(playerState.lane,playerState.targetLane,0.2);
        const tP=path.getPositionAt(playerState.progress,playerState.lane); let gY=tP.y;
        if(playerState.isJumping){player.position.y+=playerState.yVelocity*delta;playerState.yVelocity+=GRAVITY*delta;if(player.position.y-1.5<=gY){player.position.y=gY+1.5;playerState.isJumping=false;triggerCameraShake(.1,.1);playerState.landImpact=.2;}}else{player.position.y=gY+1.5;}
        player.position.x=tP.x; player.position.z=tP.z;
        const tR=path.getRotationAt(playerState.progress); player.quaternion.slerp(tR,.1);
        player.getObjectByName('shield').visible=playerState.hasShield;
        const rC=Math.sin(clock.getElapsedTime()*15),lA=player.getObjectByName('leftArm'),rA=player.getObjectByName('rightArm'),lL=player.getObjectByName('leftLeg'),rL=player.getObjectByName('rightLeg');
        let tT=(playerState.targetLane-playerState.lane)*-1.2; let scaleY=1;
        if(playerState.jumpAnticipation>0){playerState.jumpAnticipation-=delta;scaleY=.8;}else if(playerState.landImpact>0){playerState.landImpact-=delta;scaleY=.8;}
        player.scale.y += (scaleY - player.scale.y) * 0.2;
        if(playerState.isSliding){playerState.slideTimer-=delta;player.rotation.x=.9;lA.rotation.x=1.5;rA.rotation.x=1.5;if(playerState.slideTimer<=0)playerState.isSliding=false;}else if(playerState.isJumping){player.rotation.x=.2;lA.rotation.x=-.5;rA.rotation.x=-.5;lL.rotation.x=.5;rL.rotation.x=.5;}else{player.rotation.x+=(0-player.rotation.x)*.2;lA.rotation.x=rC*.5;rA.rotation.x=-rC*.5;lL.rotation.x=-rC*.5;rL.rotation.x=rC*.5;}
        if(playerState.isStumbling)tT+=Math.sin(clock.getElapsedTime()*50)*.4;
        player.rotation.z+=(tT-player.rotation.z)*.1;
    }
    function updateCollectibles(delta){for(const c of path.collectibles){c.rotation.y+=delta*2;}}
    function updateChaser(){const iD=20+playerState.fuel/5,cTP=playerState.progress-iD/path.segmentLength;if(cTP<0)return;const tP=path.getPositionAt(cTP,1);tP.y+=2;chaser.position.lerp(tP,.05);if(player.position.distanceTo(chaser.position)<7)endGame();}
    function updateMagnet(delta){if(!playerState.isMagnetActive)return;playerState.magnetTimer-=delta;if(playerState.magnetTimer<=0)playerState.isMagnetActive=false;path.collectibles.forEach(c=>{if(c.userData.type==='coin'&&c.position.distanceTo(player.position)<15){c.position.lerp(player.position,.1);}});}
    function checkCollisions(){for(let i=path.objects.length-1;i>=0;i--){const o=path.objects[i];if(!o||!o.parent)continue;const d=player.position.distanceTo(o.position);if(d<2.5)handleCollision(o,i);}}
    function handleCollision(o,i){const t=o.userData.type;if(playerState.isBoosting&&t!=='fuel'&&t!=='coin')return;if(t==='obstacle'){const oT=o.userData.obsType,iS=(oT==='jump'&&playerState.isJumping)||(oT==='slide'&&playerState.isSliding);if(!iS){if(playerState.hasShield){playerState.hasShield=false;}else endGame();scene.remove(o);path.objects.splice(i,1);}}else if(t==='stumble'){if(!playerState.isJumping){if(playerState.hasShield){playerState.hasShield=false;}else{playerState.isStumbling=true;playerState.stumbleTimer=.5;playerState.speed*=.2;audioManager.play('stumble');triggerCameraShake(.3,.5);}scene.remove(o);path.objects.splice(i,1);}}else{if(t==='fuel')playerState.fuel=Math.min(100,playerState.fuel+20);if(t==='shield')playerState.hasShield=true;if(t==='magnet'){playerState.isMagnetActive=true;playerState.magnetTimer=10;godRays.explode(player.position);}if(t==='boost'){playerState.isBoosting=true;playerState.boostTimer=5;audioManager.play('boost');godRays.explode(player.position);}if(t==='coin'){playerState.score+=200;particleSystem.explode(o.position);}audioManager.play('collect');scene.remove(o);path.objects.splice(i,1);const cI=path.collectibles.indexOf(o);if(cI>-1)path.collectibles.splice(cI,1);}}
    function updateHUD(delta){let tS;if(playerState.isBoosting){playerState.boostTimer-=delta;tS=playerState.baseSpeed*3.5;if(playerState.boostTimer<=0)playerState.isBoosting=false;}else if(playerState.isStumbling){tS=playerState.baseSpeed*.2;}else{tS=playerState.baseSpeed*(.8+playerState.fuel/150);}playerState.speed+=(tS-playerState.speed)*.1;playerState.fuel=Math.max(0,playerState.fuel-delta*4);if(!playerState.isBoosting) playerState.score+=Math.floor(playerState.speed*delta*2); else playerState.score+=Math.floor(playerState.speed*delta*4); ui.fuelBar.style.width=playerState.fuel+'%';ui.score.innerText=playerState.score;ui.shieldIcon.style.display=playerState.hasShield?'block':'none';ui.magnetIcon.style.display=playerState.isMagnetActive?'block':'none';ui.boostIcon.style.display=playerState.isBoosting?'block':'none';if(playerState.fuel<=0.1)endGame(); if(playerState.score >= playerState.nextScoreMilestone) checkReward();}
    let shakeIntensity=0,shakeTimer=0;function triggerCameraShake(i,d){shakeIntensity=i;shakeTimer=d;}
    function updateCamera(delta){if(shakeTimer>0){shakeTimer-=delta;camera.position.x+=(Math.random()-.5)*shakeIntensity;camera.position.y+=(Math.random()-.5)*shakeIntensity;}const tF=playerState.isBoosting?BASE_FOV+20:BASE_FOV;camera.fov+=(tF-camera.fov)*.1;camera.updateProjectionMatrix();if(playerState.isBoosting)speedLines.show();const tP=playerState.progress-1.0,cP=path.getPositionAt(tP,playerState.lane);cP.y+=4.5;camera.position.lerp(cP,.1);const lAP=path.getPositionAt(playerState.progress+6,playerState.lane);lAP.y+=1.5;camera.lookAt(lAP);}
    function endGame(){if(gameState==='gameOver')return;gameState='gameOver';audioManager.stopMusic();audioManager.play('crash');ui.hud.style.display='none';if(playerState.score>=REVIVE_COST&&!playerState.hasRevived){ui.reviveScreen.style.display='flex';}else{showGameOver();}}
    function showGameOver(){ui.reviveScreen.style.display='none';ui.gameOver.style.display='block';ui.finalScore.innerText=`Final Score: ${playerState.score}`; }
    function revivePlayer(){if(playerState.score<REVIVE_COST)return;playerState.score-=REVIVE_COST;playerState.hasRevived=true;playerState.fuel=100;playerState.isStumbling=false;playerState.isBoosting=false;playerState.speed=playerState.baseSpeed;playerState.progress+=2;chaser.position.z+=30;ui.reviveScreen.style.display='none';ui.hud.style.display='flex';gameState='playing';audioManager.startMusic();audioManager.play('revive');animate();}
    function onWindowResize(){camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix();renderer.setSize(window.innerWidth,window.innerHeight);composer.setSize(window.innerWidth,window.innerHeight);}
    function checkReward() {
        if (playerState.score < playerState.nextScoreMilestone) return;

        let videoToPlay = null;
        if (playerState.nextScoreMilestone === 4000) {
            videoToPlay = 'vid4.mp4';
            playerState.nextScoreMilestone = Infinity;
        } else {
            const videoIndex = ((playerState.nextScoreMilestone / 1000) - 1) % 3 + 1;
            videoToPlay = `vid${videoIndex}.mp4`;
            playerState.nextScoreMilestone += 1000;
        }

        if (videoToPlay) {
            gameState = 'paused';
            audioManager.stopMusic();
            ui.videoContainer.style.display = 'flex';
            ui.rewardVideo.src = videoToPlay;
            ui.rewardVideo.play();
            
            if (ui.rewardVideo.requestFullscreen) {
                ui.rewardVideo.requestFullscreen();
            }
            ui.rewardVideo.onended = continueGame;
        }
    }
    function continueGame() {
        if (document.exitFullscreen && document.fullscreenElement) {
            document.exitFullscreen();
        }
        ui.videoContainer.style.display = 'none';
        ui.rewardVideo.pause();
        ui.rewardVideo.onended = null;
        
        gameState = 'playing';
        audioManager.startMusic();
        animate();
    }
    function toggleMusic() {
        audioManager.toggleMusic();
        ui.musicToggleButton.innerText = audioManager.isMuted ? 'üîá' : 'üîä';
    }
    function animate(){if(gameState!=='playing')return;requestAnimationFrame(animate);const d=clock.getDelta();if(d>0.1)return;path.update();updatePlayer(d);updateChaser();updateCamera(d);checkCollisions();updateHUD(d);updateCollectibles(d);particleSystem.update(d);updateMagnet(d);speedLines.update(d);godRays.update(d);composer.render();}
    init();
    </script>
</body>
</html>
"
make the person a bit faster and for coin each coin now should provide 200 points okay ? and make the game immersive

